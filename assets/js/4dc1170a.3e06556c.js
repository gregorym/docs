"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8572],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return h}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(n),h=r,m=u["".concat(d,".").concat(h)]||u[h]||c[h]||i;return n?a.createElement(m,o(o({ref:t},l),{},{components:n})):a.createElement(m,o({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},23093:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return o},default:function(){return c},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return p}});var a=n(83117),r=(n(67294),n(3905));const i={},o="Overview",s={unversionedId:"guides/archived/architecture/deep_dive/overview",id:"guides/archived/architecture/deep_dive/overview",title:"Overview",description:"The Token Metadata contract can be used for storing generic metadata about any given mint, whether NFT or not. Metadata",source:"@site/docs/04-guides/07-archived/00-architecture/02-deep_dive/overview.md",sourceDirName:"04-guides/07-archived/00-architecture/02-deep_dive",slug:"/guides/archived/architecture/deep_dive/overview",permalink:"/guides/archived/architecture/deep_dive/overview",draft:!1,editUrl:"https://github.com/metaplex/docs/tree/main/docs/04-guides/07-archived/00-architecture/02-deep_dive/overview.md",tags:[],version:"current",lastUpdatedAt:1688850064,formattedLastUpdatedAt:"Jul 8, 2023",frontMatter:{},sidebar:"sidebar",previous:{title:"Basic Single Item Auction End To End",permalink:"/guides/archived/architecture/basic_flow"},next:{title:"Token Vault",permalink:"/guides/archived/architecture/deep_dive/token_vault"}},d={},p=[{value:"Types",id:"types",level:3},{value:"Metadata",id:"metadata",level:3},{value:"Master Edition",id:"master-edition",level:3},{value:"Edition",id:"edition",level:3},{value:"Concepts",id:"concepts",level:2},{value:"Decoration as PDA Extensions",id:"decoration-as-pda-extensions",level:3},{value:"Co-Creators",id:"co-creators",level:3},{value:"URI JSON Schema",id:"uri-json-schema",level:3}],l={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"overview"},"Overview"),(0,r.kt)("p",null,"The Token Metadata contract can be used for storing generic metadata about any given mint, whether NFT or not. Metadata\nallows storage of name, symbol, and URI to an external resource. Additionally, the Metadata allows for the tracking of\ncreators, primary sales, and seller fees. Once the mint has been created, the mint authority can use the SPL Metadata\nprogram to create metadata as described in this document."),(0,r.kt)("p",null,"Minting an NFT requires creating a new SPL Mint with the supply of one and decimals zero as\ndescribed ",(0,r.kt)("a",{parentName:"p",href:"https://spl.solana.com/token#example-create-a-non-fungible-token"},"https://spl.solana.com/token#example-create-a-non-fungible-token")),(0,r.kt)("p",null,"Below is the Rust representation of the structs that are stored on-chain."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\n#[repr(C)]\n#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug, Clone)]\npub struct Data {\n    /// The name of the asset\n    pub name: String,\n    /// The symbol for the asset\n    pub symbol: String,\n    /// URI pointing to JSON representing the asset\n    pub uri: String,\n    /// Royalty basis points that goes to creators in secondary sales (0-10000)\n    pub seller_fee_basis_points: u16,\n    /// Array of creators, optional\n    pub creators: Option<Vec<Creator>>,\n}\n\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, Debug)]\npub struct Metadata {\n    pub key: Key,\n    pub update_authority: Pubkey,\n    pub mint: Pubkey,\n    pub data: Data,\n    // Immutable, once flipped, all sales of this metadata are considered secondary.\n    pub primary_sale_happened: bool,\n    // Whether or not the data struct is mutable, default is not\n    pub is_mutable: bool,\n}\n\n#[repr(C)]\n#[derive(Clone, Debug, PartialEq, BorshSerialize, BorshDeserialize)]\npub struct MasterEdition {\n    pub key: Key,\n    pub supply: u64,\n    pub max_supply: Option<u64>,\n}\n\n#[repr(C)]\n#[derive(Clone, Debug, PartialEq, BorshSerialize, BorshDeserialize)]\n/// All Editions should never have a supply greater than 1.\n/// To enforce this, a transfer mint authority instruction will happen when\n/// a normal token is turned into an Edition, and in order for a Metadata update authority\n/// to do this transaction they will also need to sign the transaction as the Mint authority.\npub struct Edition {\n    pub key: Key,\n\n    /// Points at MasterEdition struct\n    pub parent: Pubkey,\n\n    /// Starting at 0 for master record, this is incremented for each edition minted.\n    pub edition: u64,\n}\n\n#[repr(C)]\n#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug, Clone)]\npub struct Creator {\n    pub address: Pubkey,\n    pub verified: bool,\n    // In percentages, NOT basis points ;) Watch out!\n    pub share: u8,\n}\n\n#[repr(C)]\n#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug, Clone)]\npub struct EditionMarker {\n    pub key: Key,\n    pub ledger: [u8; 31],\n}\n\n")),(0,r.kt)("p",null,"The instruction set for the token metadata contract can be\nfound ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/metaplex-foundation/metaplex-program-library/blob/master/token-metadata/program/src/instruction.rs"},"here"),"\n."),(0,r.kt)("h3",{id:"types"},"Types"),(0,r.kt)("h3",{id:"metadata"},"Metadata"),(0,r.kt)("p",null,"This object can be used to provide basic info about SPL tokens on Solana, which include the name, symbol, URI and seller\nfees, as well as whether the sale of this metadata has happened yet. Anybody carrying a token from this mint can\nmark this primary sale as having happened via the ",(0,r.kt)("inlineCode",{parentName:"p"},"update_primary_sale_happened_via_token")," command. There is obviously\nno incentive for a primary owner to do this as it precludes them from getting full royalties on the first sale, but a\nsecondary owner must do this if they ever want to see fees from selling!"),(0,r.kt)("p",null,"Metadata accounts are simply PDA addresses with derived key of ",(0,r.kt)("inlineCode",{parentName:"p"},"['metadata', token_metadata_program_id, mint_id]"),"."),(0,r.kt)("h3",{id:"master-edition"},"Master Edition"),(0,r.kt)("p",null,"In addition to simple metadata, a Master Edition object can be created. Master Editions act similar to a token mint and\nallows the holder to create new number editions while tracking provenance of the items. A Master Edition token, when\nminted, represents both a non-fungible token on Solana and metadata that allows creators to control the provenance of\nprints created from the master edition. A Master Edition object can only be created for mints with supply of one and\ndecimals of zero."),(0,r.kt)("p",null,"The creator can set the maximum supply of the master edition just like a regular mint on Solana, with the main\ndifference being that each print is a numbered edition created from it. To mint a new limited edition, this master\nedition token must be presented, along with a new mint + token, to the ",(0,r.kt)("inlineCode",{parentName:"p"},"mint_new_edition_from_master_edition_via_token"),"\nendpoint."),(0,r.kt)("p",null,"Master Edition accounts are PDA addresses of ",(0,r.kt)("inlineCode",{parentName:"p"},"['metadata', token_metadata_program_id, mint_id, 'edition']"),"."),(0,r.kt)("h3",{id:"edition"},"Edition"),(0,r.kt)("p",null,"An edition represents a copy of an NFT, and is created from a Master Edition. Each print has an edition number\nassociated with it. Normally, prints can be created during Open Edition or Limited Edition auction, but they could also\nbe created by the creator manually."),(0,r.kt)("p",null,"Editions are created by presenting the Master Edition token, along with a new mint that lacks a Metadata account and a\ntoken account containing one token from that mint to the ",(0,r.kt)("inlineCode",{parentName:"p"},"mint_new_edition_from_master_edition_via_token")," endpoint. This\nendpoint will create both an immutable Metadata based on the parent Metadata and a special Edition struct based on the\nparent Master Edition struct."),(0,r.kt)("p",null,"The Edition has the same PDA as a Master Edition to force collision and prevent a user from having a mint with\nboth, ",(0,r.kt)("inlineCode",{parentName:"p"},"['metadata', token_metadata_program_id, mint_id, 'edition']"),"."),(0,r.kt)("h2",{id:"concepts"},"Concepts"),(0,r.kt)("h3",{id:"decoration-as-pda-extensions"},"Decoration as PDA Extensions"),(0,r.kt)("p",null,"The whole idea of the Token Metadata program is to be a decorator to a Token Mint. Each struct acts as further\ndecoration. The Metadata struct gives a mint a name and a symbol and points to some external URI that can be anything.\nThe Master Edition gives it printing capabilities. The Edition labels it as a child of something."),(0,r.kt)("p",null,"This is important to internalize, because it means you as a Rust developer can take it a step further. There is nothing\nstopping you from building a new contract on top of ours that makes its own PDAs and extending this still further.\nWhy not build a CookingRecipes PDA, that has seed ",(0,r.kt)("inlineCode",{parentName:"p"},"['your-app', your_program_id, mint_id, 'recipes']"),"? You can require\nthat a Metadata PDA from our contract exists to make a PDA in your program, and then you can further decorate mints on\ntop of our decorations. The idea is to compose mints with further information than they ever had before, and then build\nclients that can consume that information in new and interesting ways."),(0,r.kt)("h3",{id:"co-creators"},"Co-Creators"),(0,r.kt)("p",null,"The Token Metadata program supports storing up to five co-creators that share potential future profits from sales for\nthe items as defined by ",(0,r.kt)("inlineCode",{parentName:"p"},"seller_fee_basis_points")," . Each creator needs to be added as part of the minting process and is\nrequired to approve metadata that was used in his name using the ",(0,r.kt)("inlineCode",{parentName:"p"},"sign_metadata")," endpoint. Unverified artwork cannot be\nsold with Metaplex."),(0,r.kt)("p",null,"During the first sale, creators share in 100% of the proceeds, while in follow-up sales, they share in proceeds as a\npercentage determined by ",(0,r.kt)("inlineCode",{parentName:"p"},"seller_fee_basis_points"),". Whether a metadata is considered in second sale or not is\ndetermined by the ",(0,r.kt)("inlineCode",{parentName:"p"},"primary_sale_happened")," boolean on the Metadata account."),(0,r.kt)("h3",{id:"uri-json-schema"},"URI JSON Schema"),(0,r.kt)("p",null,"The URI resource is compatible\nwith ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md#erc-1155-metadata-uri-json-schema"},"ERC-1155 JSON Schema"),"\nin order to easily port NFTs across different chains using the wormhole bridge. You can see how we build this in our\nreference implementation\nhere: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/metaplex-foundation/metaplex/blob/master/js/packages/web/src/actions/nft.tsx#L66"},"https://github.com/metaplex-foundation/metaplex/blob/master/js/packages/web/src/actions/nft.tsx#L66")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "title": "Token Metadata",\n  "type": "object",\n  "properties": {\n    "name": {\n      "type": "string",\n      "description": "Identifies the asset to which this token represents"\n    },\n    "description": {\n      "type": "string",\n      "description": "Describes the asset to which this token represents"\n    },\n    "image": {\n      "type": "string",\n      "description": "A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."\n    },\n    "external_url": {\n      "type": "string",\n      "description": "A URI pointing to an external resource that will take user outside of the platform."\n    },\n    "seller_fee_basis_points": {\n      "type": "number"\n    },\n    "properties": {\n      "type": "object",\n      "description": "Arbitrary properties. Values may be strings, numbers, object or arrays.",\n      "properties": {\n        "creators": {\n          "type": "array",\n          "description": "Contains list of creators, each with Solana address and share of the nft"\n        }\n      }\n    }\n  }\n}\n')))}c.isMDXComponent=!0}}]);