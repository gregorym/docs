"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),u=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),h=u(n),p=a,m=h["".concat(s,".").concat(p)]||h[p]||l[p]||o;return n?i.createElement(m,r(r({ref:t},c),{},{components:n})):i.createElement(m,r({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var d={};for(var s in t)hasOwnProperty.call(t,s)&&(d[s]=t[s]);d.originalType=e,d.mdxType="string"==typeof e?e:a,r[1]=d;for(var u=2;u<o;u++)r[u]=n[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},26961:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return r},default:function(){return l},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return u}});var i=n(83117),a=(n(67294),n(3905));const o={},r="Auction",d={unversionedId:"guides/archived/architecture/deep_dive/auction",id:"guides/archived/architecture/deep_dive/auction",title:"Auction",description:"Overview",source:"@site/docs/04-guides/07-archived/00-architecture/02-deep_dive/01-auction.md",sourceDirName:"04-guides/07-archived/00-architecture/02-deep_dive",slug:"/guides/archived/architecture/deep_dive/auction",permalink:"/guides/archived/architecture/deep_dive/auction",draft:!1,editUrl:"https://github.com/metaplex/docs/tree/main/docs/04-guides/07-archived/00-architecture/02-deep_dive/01-auction.md",tags:[],version:"current",lastUpdatedAt:1688758618,formattedLastUpdatedAt:"Jul 7, 2023",sidebarPosition:1,frontMatter:{},sidebar:"sidebar",previous:{title:"Token Vault",permalink:"/guides/archived/architecture/deep_dive/token_vault"},next:{title:"Metaplex",permalink:"/guides/archived/architecture/deep_dive/metaplex"}},s={},u=[{value:"Overview",id:"overview",level:2},{value:"Types",id:"types",level:2},{value:"AuctionData",id:"auctiondata",level:3},{value:"Bid State",id:"bid-state",level:3},{value:"BidderMetadata",id:"biddermetadata",level:3},{value:"BidderPot",id:"bidderpot",level:3},{value:"AuctionDataExtended",id:"auctiondataextended",level:3},{value:"Concepts",id:"concepts",level:2},{value:"Incompleteness",id:"incompleteness",level:3},{value:"Cancelling before Placing a Bid",id:"cancelling-before-placing-a-bid",level:3},{value:"Claiming bids",id:"claiming-bids",level:3},{value:"Refunds",id:"refunds",level:3},{value:"Turning the Crank",id:"turning-the-crank",level:3}],c={toc:u};function l(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"auction"},"Auction"),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"The Auction contract is a primitive that is meant to be used in conjunction with another smart contract that understands the context of the resource for which the auction is being held. It contains mechanics for collecting payment from bidders, for keeping track of a winners list, and handling bid placement and cancellation, but it has no opinions on what the resource being bid on should be, or how it gets divided."),(0,a.kt)("p",null,"It currently has support for English Auctions and Open Edition Auctions. The state for the contract is reproduced here:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'/// Structure with pricing floor data.\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, PartialEq, Debug)]\npub enum PriceFloor {\n    /// Due to borsh on the front end disallowing different arguments in enums, we have to make sure data is\n    /// same size across all three\n    /// No price floor, any bid is valid.\n    None([u8; 32]),\n    /// Explicit minimum price, any bid below this is rejected.\n    MinimumPrice([u64; 4]),\n    /// Hidden minimum price, revealed at the end of the auction.\n    BlindedPrice(Hash),\n}\n\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, PartialEq, Debug)]\npub struct AuctionData {\n    /// Pubkey of the authority with permission to modify this auction.\n    pub authority: Pubkey,\n    /// Pubkey of the resource being bid on.\n    /// TODO try to bring this back some day. Had to remove this due to a stack access violation bug\n    /// interacting that happens in metaplex during redemptions due to some low level rust error\n    /// that happens when AuctionData has too many fields. This field was the least used.\n    ///pub resource: Pubkey,\n    /// Token mint for the SPL token being used to bid\n    pub token_mint: Pubkey,\n    /// The time the last bid was placed, used to keep track of auction timing.\n    pub last_bid: Option<UnixTimestamp>,\n    /// Slot time the auction was officially ended by.\n    pub ended_at: Option<UnixTimestamp>,\n    /// End time is the cut-off point that the auction is forced to end by.\n    pub end_auction_at: Option<UnixTimestamp>,\n    /// Gap time is the amount of time in slots after the previous bid at which the auction ends.\n    pub end_auction_gap: Option<UnixTimestamp>,\n    /// Minimum price for any bid to meet.\n    pub price_floor: PriceFloor,\n    /// The state the auction is in, whether it has started or ended.\n    pub state: AuctionState,\n    /// Auction Bids, each user may have one bid open at a time.\n    pub bid_state: BidState,\n}\n\n// Further storage for more fields. Would like to store more on the main data but due\n// to a borsh issue that causes more added fields to inflict "Access violation" errors\n// during redemption in main Metaplex app for no reason, we had to add this nasty PDA.\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, PartialEq, Debug)]\npub struct AuctionDataExtended {\n    /// Total uncancelled bids\n    pub total_uncancelled_bids: u64,\n    // Unimplemented fields\n    /// Tick size\n    pub tick_size: Option<u64>,\n    /// gap_tick_size_percentage - two decimal points\n    pub gap_tick_size_percentage: Option<u8>,\n}\n\n/// Define valid auction state transitions.\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, PartialEq, Debug)]\npub enum AuctionState {\n    Created,\n    Started,\n    Ended,\n}\n\n/// Bids associate a bidding key with an amount bid.\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, PartialEq, Debug)]\npub struct Bid(pub Pubkey, pub u64);\n\n/// BidState tracks the running state of an auction, each variant represents a different kind of\n/// auction being run.\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, PartialEq, Debug)]\npub enum BidState {\n    EnglishAuction { bids: Vec<Bid>, max: usize },\n    OpenEdition { bids: Vec<Bid>, max: usize },\n}\n\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, PartialEq, Debug)]\npub enum WinnerLimit {\n    Unlimited(usize),\n    Capped(usize),\n}\n\n/// Models a set of metadata for a bidder, meant to be stored in a PDA. This allows looking up\n/// information about a bidder regardless of if they have won, lost or cancelled.\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, PartialEq, Debug)]\npub struct BidderMetadata {\n    // Relationship with the bidder who\'s metadata this covers.\n    pub bidder_pubkey: Pubkey,\n    // Relationship with the auction this bid was placed on.\n    pub auction_pubkey: Pubkey,\n    // Amount that the user bid.\n    pub last_bid: u64,\n    // Tracks the last time this user bid.\n    pub last_bid_timestamp: UnixTimestamp,\n    // Whether the last bid the user made was cancelled. This should also be enough to know if the\n    // user is a winner, as if cancelled it implies previous bids were also cancelled.\n    pub cancelled: bool,\n}\n\n#[repr(C)]\n#[derive(Clone, BorshSerialize, BorshDeserialize, PartialEq)]\npub struct BidderPot {\n    /// Points at actual pot that is a token account\n    pub bidder_pot: Pubkey,\n    /// Originating bidder account\n    pub bidder_act: Pubkey,\n    /// Auction account\n    pub auction_act: Pubkey,\n    /// emptied or not\n    pub emptied: bool,\n}\n\n')),(0,a.kt)("p",null,"The instruction set for auction can be found here: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/metaplex-foundation/metaplex-program-library/blob/master/auction/program/src/instruction.rs"},"https://github.com/metaplex-foundation/metaplex-program-library/blob/master/auction/program/src/instruction.rs")),(0,a.kt)("h2",{id:"types"},"Types"),(0,a.kt)("h3",{id:"auctiondata"},"AuctionData"),(0,a.kt)("p",null,"This is the core data representing an auction in this program. It contains (almost) all the configuration representing an auction. You'll notice that it has a ",(0,a.kt)("inlineCode",{parentName:"p"},"token_mint")," field which means any spl_token can be used as the base mint for an auction, so you can bid in any currency! It also keeps track of a few other goodies, so let's break them down one by one:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"last_bid"),": Every time someone bids, this is set. Useful for doing math with the gap time feature."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ended_at")," : This is when the auction actually will end or has ended. It can be set at any time."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"end_auction_at")," : This is actually a duration and is a little confusing. If you're planning to start your auction at a later point in time, you can set this as a duration, and when you finally start your auction, ended_at will be set to now + this duration. Useful, right? Maybe poorly named. Our bad."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"end_auction_gap")," : Used in conjunction with ",(0,a.kt)("inlineCode",{parentName:"p"},"last_bid")," - if this is set to 1 minute, then let's say someone makes a bid in the last 5 seconds of an auction. The auction is then extended by 55 seconds from its original end time (+ 1 minute from the last bid.) If someone then makes another bid within that time period, it's another + 1 minute from that bid. And so on."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"price_floor")," : Various options for price floor, but essentially you can use this to set no price floor, a minimum price floor, or a blind price floor on the auction. See the enum for more."),(0,a.kt)("p",null,"AuctionData accounts always have PDA addresses of ",(0,a.kt)("inlineCode",{parentName:"p"},"['auction', auction_program_id, resource_id]")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"resource_id")," is the thing being auctioned off and ",(0,a.kt)("inlineCode",{parentName:"p"},"auction_program_id")," is the id of the auction contract."),(0,a.kt)("h3",{id:"bid-state"},"Bid State"),(0,a.kt)("p",null,"Bid State is technically not a top level struct, but an embedded one within AuctionData. I thought it was good to give it a section anyway because it's a complex little beast. It's actually an enum that holds a bid vector and a maximum size denoting how many of those bids are actually \"valid winners\" vs just placeholders."),(0,a.kt)("p",null,"It's reversed, which is to say that the number one winner is always at the end of the vec. It's also always bigger generally than the number of winners so that if a bid is cancelled, we have some people who got bumped out of top spots that can be moved back into them without having to cancel and replace their bids. When a bid is placed, it is inserted in the proper position based on it's amount and then the lowest bidder is bumped off the 0th position of the vec if the vec is at max size, so the vec remains sorted at all times."),(0,a.kt)("p",null,"In the case of open edition, the max is always zero, ie there are never any winners, and we are just accepting bids and creating BidderMetadata tickets and BidderPots to accept payment for (probably) fixed price Participation NFTs."),(0,a.kt)("p",null,"We would prefer that OpenEdition enum have no bid vector and no max, but unfortunately borsh-js does not support enums with different internal data structures, so all data structures in an enum must be identical (even if unused.) Keep that in mind when designing your own end to end borsh implementations!"),(0,a.kt)("h3",{id:"biddermetadata"},"BidderMetadata"),(0,a.kt)("p",null,"This is created and/or updated during the ",(0,a.kt)("inlineCode",{parentName:"p"},"place_bid")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"cancel_bid")," endpoints of the contract, and acts as proof to other contracts and this one that a bidder actually placed a bid, because there is no guarantee that this bidder will have an entry in the actual BidState as they could've gotten knocked off the array in high periods of bidder activity."),(0,a.kt)("p",null,"BidderMetadata always has a PDA of ",(0,a.kt)("inlineCode",{parentName:"p"},"['auction', auction_program_id, auction_id, bidder_key, 'metadata']")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"auction_program_id")," is the program id of the auction contract, ",(0,a.kt)("inlineCode",{parentName:"p"},"auction_id")," is the key of the auction, and ",(0,a.kt)("inlineCode",{parentName:"p"},"bidder_key")," is the wallet making the bid."),(0,a.kt)("h3",{id:"bidderpot"},"BidderPot"),(0,a.kt)("p",null,"This ended up being a bit of a redundant struct, but this serves as a join table between the actual token account containing the funds collected by the auction for a given bidder, the bidder's sol wallet, and an auction. In the future we may merge this struct into BidderMetadata. There is also an ",(0,a.kt)("inlineCode",{parentName:"p"},"emptied")," boolean on it to track whether the bidder pot has been claimed by the auctioneer for easy lookup."),(0,a.kt)("p",null,"BidderPot always has a PDA of ",(0,a.kt)("inlineCode",{parentName:"p"},"['auction', auction_program_id, auction_id, bidder_key]"),"where ",(0,a.kt)("inlineCode",{parentName:"p"},"auction_program_id")," is the program id of the auction contract, ",(0,a.kt)("inlineCode",{parentName:"p"},"auction_id")," is the key of the auction, and ",(0,a.kt)("inlineCode",{parentName:"p"},"bidder_key")," is the wallet making the bid."),(0,a.kt)("h3",{id:"auctiondataextended"},"AuctionDataExtended"),(0,a.kt)("p",null,"If you've read this far, you now get to witness my personal shame. So as it turns out, if you build a complex enough program with enough structs flying around, there is some kind of weird interaction in the Metaplex contract that causes it to blow out with an access violation if you add more than a certain number of keys to one particular struct (AuctionData), and ",(0,a.kt)("em",{parentName:"p"},"only")," during the redemption endpoint calls. We were unable to discern why this was across 3 days of debugging. We had a theory it was due to some issue with borsh, but it is not 100% certain, as we're not experts with that library's internals."),(0,a.kt)("p",null,"Instead, our work-around was to introduce AuctionDataExtended to add new fields that we needed to AuctionData without breaking this hidden bug that seems to exist. What is odd about the whole thing is adding fields to ",(0,a.kt)("em",{parentName:"p"},"other")," structs doesn't cause any issues. In the future I'd love to have someone who knows way more than me about these subjects weigh in and tell me what I did wrong here to resolve this split-brain problem! We also don't have reverse lookup capability (Resource key on AuctionData) because of this bug - adding it would cause the blow out I mentioned."),(0,a.kt)("p",null,"Another note here is ",(0,a.kt)("inlineCode",{parentName:"p"},"gap_tick_size_percentage")," as of the time of this writing has not been implemented yet, it is just a dummy field."),(0,a.kt)("p",null,"AuctionDataExtended accounts always have PDA addresses of ",(0,a.kt)("inlineCode",{parentName:"p"},"['auction', auction_program_id, resource_id, 'extended']")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"resource_id")," is the thing being auctioned off and ",(0,a.kt)("inlineCode",{parentName:"p"},"auction_program_id")," is the id of the auction contract."),(0,a.kt)("h2",{id:"concepts"},"Concepts"),(0,a.kt)("h3",{id:"incompleteness"},"Incompleteness"),(0,a.kt)("p",null,'The contract currently has a deficiency in its implementation where an auctioneer can claim the funds for a winning bid without the winner having signed off on having received some sort of prize for that bid - which is why we mention the "conjunction" above in the Overview. Metaplex guarantees through the interaction with the Metaplex contract that all users of Metaplex + Auction combination get a prize, but use of Auction by itself does not guarantee a winner gets a prize for a bid, because this functionality does not exist in this contract alone yet. A future version of this contract will require the winning bidders to create a PDA admitting they have received a prize before the auctioneer can withdraw funds, making this a complete primitive that can be used without any other contract making guarantees.'),(0,a.kt)("p",null,"The way Metaplex makes such a guarantee is that it controls the Vault resource being bid on, and if you present the Metaplex contract with a BidderMetadata account from the Auction that represents a winning bid, it will disburse the proper NFT to you from the Vault. You can do the same with your own custom implementation."),(0,a.kt)("h3",{id:"cancelling-before-placing-a-bid"},"Cancelling before Placing a Bid"),(0,a.kt)("p",null,"Currently, you cannot change or place a new bid until you cancel the old one. Just keep that in mind - it makes for easier logic all around. This may change in the future as we add support for bidders not being able to cancel once a bid is placed, or not being able to bid less than they previously bid."),(0,a.kt)("h3",{id:"claiming-bids"},"Claiming bids"),(0,a.kt)("p",null,"Pulling money out of the auction contract as an auctioneer can only be done after an auction has ended and must be done for each winning bid, one after the other. You provide a destination token account and drain each bidder pot to it via the ",(0,a.kt)("inlineCode",{parentName:"p"},"claim_bid")," endpoint."),(0,a.kt)("h3",{id:"refunds"},"Refunds"),(0,a.kt)("p",null,'Refunds work by cancelling bids. Currently, any bidder can cancel any time during an auction, but only non-winners of the auction can cancel after it ends. When users cancel, they receive full refunds. The "refund bid" button on the front end just cancels the bid.'),(0,a.kt)("h3",{id:"turning-the-crank"},"Turning the Crank"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"place_bid")," will turn the state of the auction to ",(0,a.kt)("strong",{parentName:"p"},"Ended")," if someone places a bid after the auction's ",(0,a.kt)("inlineCode",{parentName:"p"},"ended_at")," date passes. It will then return ",(0,a.kt)("inlineCode",{parentName:"p"},"Ok(())")," in a kind of silent pass without actually placing a bid. Once the auction is in the ",(0,a.kt)("strong",{parentName:"p"},"Ended")," state, bid funds can be claimed by the auctioneer. This is actually how an auction is really ended - it does not end on its own accord, someone has to turn the crank! In theory, an auction will remain open for all eternity, past its own end date, if nobody touches it, but nobody can do any invalid things to it. It's kind of like Schr\xf6dinger's Cat. However, even if an auction is not officially in ",(0,a.kt)("strong",{parentName:"p"},"Ended")," state, but it is past its ",(0,a.kt)("inlineCode",{parentName:"p"},"ended_at"),", winners will not be allowed to cancel bids."))}l.isMDXComponent=!0}}]);